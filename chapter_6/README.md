前半本书都是描述构建一个计算机硬件平台。第二部分专注于计算机软件层级。最终目的是开发一个简单的，基于面向对象语言的编译器和基础的计算机系统。

整个章节最基础和重要的模组就是编译器。

在之前的第四章从汇编和二进制表述展示了机器语言。这个章节描述了编译器是如何系统性的将程序从之前的状态翻译成后面状态的。（从汇编到二进制）。

随着这个章节的展开，我们解释了如何开发一个HACK编译器。这个编译器可以生成可以在之前第五章中构建的硬件平台上运行的二进制代码。

因为汇编指令和对应的二进制代码的对应关系很直接，这就意味着写一个使用高级语言的汇编器不是什么难事。

允许汇编程序使用对内存地址的符号引用会引起复杂的问题。汇编器会被赋予管理这些用户定义的符号的期望，还要把他们解析到对应的物理存储地址。

通常会使用符号表去解决这个问题。**符号表**是解决许多软件翻译项目要用到的经典的数据结构。

和往常一样，HACK汇编器并不是终点。它简单且精确的演示了构建任何编译器需要用到的关键的软件工程原则。

此外，编写一个编译器是这本书剩余的七个软件开发项目的第一个。并不像之前用HDL描述的硬件项目。构建翻译程序的软件项目可以用任何编程语言实现。在每个项目中，我们都会提供自然语言的API，和每一步测试计划。这些项目的每一个都会以编译器开头，却都是独立的模组，都可以独立测试。（孤岛）。



从本章节开始讨论软件阶层体系.6-12 章节致力于构建能够编译简单**面向对象语言开发的编译器**和基本的**操作系统**为止.在软件体系中最基本的模块就是**编译器(assembler)**,前面说过机器语言的两种表现形式,**汇编形式**和**二进制形式**,

本章节用来构建一个汇编编译器.目的在于将

```asm
@1024
D=A
```

转换成 16 位的二进制编码

```bash
0000 0010 0000 0000 // a指令 instruction[14] => 1024
1110 xxxx xx00 0000 // c指令
```

[汇编编译器跳转链接](../projects/06/assembler)



6.1 背景

