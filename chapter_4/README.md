# 第 4 章 机器语言

我们可用结构化 的方式来描述计算机,给出他的硬件平台,然后解释它是如何由一些底层芯片构成的.也可以通过描述和演示机器语言的功能来抽象的描述计算机.事实上,要开始了解一个新的计算机系统,先去阅读一些机器语言编写的底层程序是十分必要的,这样不仅有助于了解如何通过程序来让计算机去执行正确的操作,还可以由此了解为什么其他硬件会按照某种特定的方式来设计,基于这种思想,本章集中讨论底层机器语言进行编程.

机器语言是一种特定的形式,用来对底层程序进行编码,从而形成一系列机器指令,应用这些指令进行编码,从而形成一系列机器指令.应用这些指令程序员可以命令处理器执行算数和逻辑操作.在内存中进行存取操作,让数据在寄存器之间传奇,验证布尔表达式的值等,高级语言的基本设计目标是通用性和较强性的的表达力,与高级语言相反,机器语言的设计目标是能直接运行在指定的硬件平台.

机器语言是整个计算机体系中意义最深奥的接口,他也是硬件和软件相接的中间线.借机器语言,程序员用符号指令表达的抽象思维被转换成执行在硅片上的物理操作.因此.可以将机器语言看做编程工作.也可以将其看做硬件平台内部不可分割的一部分.事实上,正如我们设计机器语言是为了使用给定的平台硬件一样,我们设计硬件平台是为了获解析并执行给定机器语言编写而成的机器语言编写而成的指令.

虽然大多数人不会用机器语言来编写程序,但是学习 底层编程是彻底理解计算机体系的必备条件,然而,你的发现是多么的激动人心,最复杂的软件系统,在底层其实是一串长基本指令,每条指令都描述了底层硬件上的一种极为简单原始的操作,还是那句话,要达到这样的理解程度,最好是手动写一些底层代码并让其在某硬件平台上面运行.

## 背景知识

本章为了对机器语言做一些一般性的描述,我们只需要集中讨论三个主要的抽象体:**处理器 processor**,**内存 memory**,以及一组**寄存器 registers**

- 机器语言,可被看做一种约定形式,他利用**处理器**和**寄存器**来操控**内存**

- **内存**,用于存储数据和指令的硬件设备.所有的内存具备相同的结构:一个连续固定宽度的单元序列,也称之为**字 word**或者内存单元,每个内存单元都是一个唯一的地址,因此对于独立的字代表一个数据项,或者说一个指令,他可以通过提供它的地址来描述.后面会用到`Memory[address]`或者`RAM[address]`,或者`M[address]`来表示内存.

- **处理器**,通常被成为 CPU 中央处理器(centeral Processing Unit),是执行一组固定基本操作的设备,这些操作通常包括算术操作和逻辑操作.内存存取操作`control operation`和控制操作`branching operation`.这些操作的对象是二进制数值,他们来自寄存器和指定的内存单元.操作的结果是处理器的输出.它可以存在寄存器内,也可以存在指定的内存单元.

- **寄存器** 内存访问的是相对较慢的操作,而且需要很长的指令格式(一个地址可能需要 32 位).基于这个原因,大多数处理器都有配一些寄存器.每个寄存器只存储一位.它挨着处理器,相当于处理器的一个高速本地内存.使得处理器能快速操控数据和指令.寄存器使得程序员能狗尽可能的使用内存访问命令.从而加速程序执行.

### 语言

机器语言是一系列编码指令,比如说在 16-位计算机上面典型的指令之一是`1010001100011001`,为了直到这个指令的意思,就必须直到语言的规则,也就是底层硬件平台的指令集和,比如这样的指令包含 4 个比特的位域(files):最左边的域是 CPU 的操作编码,剩下的三部分表示该操作的操作数,因此根据硬件平台上的机器语言语法,前面代表了`set R3 to R1+R9`

鉴于二进制编码相当晦涩,通常在机器语言中同时使用二进制编码和助记符.它的名字暗示了其代表的意思,比如`1010`用`add`表示.因此`1010001100011001`表示为`add R3 R1 R9`.

将这种抽象符号进一步发展,我们不仅能够阅读符号表示,而且能实际的利用这些命令符号而不是二进制来编写程序,接下来,可以使用文本处理程序,将这些命令解析成其内容含义.生成对应的二进制表示码.因此符号也称为**汇编语言(assembly language)**,或者说成简单的汇编,而将汇编编译成二进制码的程序则称为**汇编编译器(assembler)**.

因为不同的计算机在 CPU 的操作方式,寄存器的数量和类型.以及汇编语法上各不相同,活像是巴别塔传说,每种计算机都有他们自己的晦涩语法,抛开差异性,所有机器语言都支持相似的通用命令集合,接下来会介绍.

### 命令 Commands

- **算数操作**和**逻辑操作** 计算机需要执行基本的算数操作(比如加法和减法),以及基本的布尔操作,.(比如按位取反,位移等等).这里给出一些例子,他们是使用典型的机器语言语法描述编写的:

```asm
ADD R1,R2,R3  // R2 <- R1+R3  其中R1,R2,R3是寄存器
ADD R1,R2,foo // R2 <- R1+foo 其中foo代表的意思是用户定义的标签foo所指向的内存单元的值
ADD R1,R2,R3  // R1 <- 对R1和R2进行安慰与(And)操作的结果
```

- **内存访问** 内存访问的命令分为两类

- 第一类,正如刚才看到的,算数命令和逻辑命令不仅允许操控寄存器,而且还可以操作特定的内存单元
- 所有计算机都会使用 load 和 store 命令,用来在寄存器和内存之间传递数据,这些访问命令可能会应用某些类型的寻址方式,并且指令中指定目标内存单元的地址,当然,不同的计算机有不同的寻址方式,下面三种大多数计算机都支持它的寻址方式:

- **直接寻址** 最常用的寻址方式,直接表示一个指定内存单元的地址,或者使用一个符号来代表

```asm
LOAD R1,67  // R1 <- Memory[67]
// 或者假设bar指向内存地址67,那么就有:
LOAD R1,bar // R1 <- Memory[67]
```

- **立即寻址** 这种寻址方式被用来加载常数 -- 也就是说,加载出来那些出现在指令代码里面的数值:我们直接将指令数据中的内容当做要操作的数据装入在指令代码里面的数值:我们直接用指令数据域中的内容当做要操作的数据装入寄存器,而不是直接将数值当做内存单元的地址:

```asm
LOADI R1,67 // R1 <- 67
```

- **间接寻址** 在这种寻址模式中,要访问的内存单元的地址没有直接出现在指令中,而是指令的内存单元中的内容代表目标内容单元的地址,这种寻址模式被用来处理**指针Pointer**这种语言设施.比如一条高级语言命令x=foo[j],这里的foo是数组变量,x和j是整数变量.那么与这条命令等价的机器语言是什么?当数组foo在高级语言中被声明并被初始化时候,编译器分配一段连续的内存单元来保存这个数组数据.并用符号foo来指代该内存单元组的**基地址(base address)**.

于是当编译器后面遇到表示数组单元的符号(比如foo[j])时候,将按照下步骤进行地址解析,首先
