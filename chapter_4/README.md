# 第 4 章 机器语言

我们可用结构化 的方式来描述计算机,给出他的硬件平台,然后解释它是如何由一些底层芯片构成的.也可以通过描述和演示机器语言的功能来抽象的描述计算机.事实上,要开始了解一个新的计算机系统,先去阅读一些机器语言编写的底层程序是十分必要的,这样不仅有助于了解如何通过程序来让计算机去执行正确的操作,还可以由此了解为什么其他硬件会按照某种特定的方式来设计,基于这种思想,本章集中讨论底层机器语言进行编程.

机器语言是一种特定的形式,用来对底层程序进行编码,从而形成一系列机器指令,应用这些指令进行编码,从而形成一系列机器指令.应用这些指令程序员可以命令处理器执行算数和逻辑操作.在内存中进行存取操作,让数据在寄存器之间传奇,验证布尔表达式的值等,高级语言的基本设计目标是通用性和较强性的的表达力,与高级语言相反,机器语言的设计目标是能直接运行在指定的硬件平台.

机器语言是整个计算机体系中意义最深奥的接口,他也是硬件和软件相接的中间线.借机器语言,程序员用符号指令表达的抽象思维被转换成执行在硅片上的物理操作.因此.可以将机器语言看做编程工作.也可以将其看做硬件平台内部不可分割的一部分.事实上,正如我们设计机器语言是为了使用给定的平台硬件一样,我们设计硬件平台是为了获解析并执行给定机器语言编写而成的机器语言编写而成的指令.

虽然大多数人不会用机器语言来编写程序,但是学习 底层编程是彻底理解计算机体系的必备条件,然而,你的发现是多么的激动人心,最复杂的软件系统,在底层其实是一串长基本指令,每条指令都描述了底层硬件上的一种极为简单原始的操作,还是那句话,要达到这样的理解程度,最好是手动写一些底层代码并让其在某硬件平台上面运行.

## 背景知识

本章为了对机器语言做一些一般性的描述,我们只需要集中讨论三个主要的抽象体:**处理器 processor**,**内存 memory**,以及一组**寄存器 registers**

- 机器语言,可被看做一种约定形式,他利用**处理器**和**寄存器**来操控**内存**

- **内存**,用于存储数据和指令的硬件设备.所有的内存具备相同的结构:一个连续固定宽度的单元序列,也称之为**字 word**或者内存单元,每个内存单元都是一个唯一的地址,因此对于独立的字代表一个数据项,或者说一个指令,他可以通过提供它的地址来描述.后面会用到`Memory[address]`或者`RAM[address]`,或者`M[address]`来表示内存.

- **处理器**,通常被成为 CPU 中央处理器(centeral Processing Unit),是执行一组固定基本操作的设备,这些操作通常包括算术操作和逻辑操作.内存存取操作`control operation`和控制操作`branching operation`.这些操作的对象是二进制数值,他们来自寄存器和指定的内存单元.操作的结果是处理器的输出.它可以存在寄存器内,也可以存在指定的内存单元.

- **寄存器** 内存访问的是相对较慢的操作,而且需要很长的指令格式(一个地址可能需要 32 位).基于这个原因,大多数处理器都有配一些寄存器.每个寄存器只存储一位.它挨着处理器,相当于处理器的一个高速本地内存.使得处理器能快速操控数据和指令.寄存器使得程序员能狗尽可能的使用内存访问命令.从而加速程序执行.

### 语言

机器语言是一系列编码指令,比如说在 16-位计算机上面典型的指令之一是`1010001100011001`,为了直到这个指令的意思,就必须直到语言的规则,也就是底层硬件平台的指令集和,比如这样的指令包含 4 个比特的位域(files):最左边的域是 CPU 的操作编码,剩下的三部分表示该操作的操作数,因此根据硬件平台上的机器语言语法,前面代表了`set R3 to R1+R9`

鉴于二进制编码相当晦涩,通常在机器语言中同时使用二进制编码和助记符.它的名字暗示了其代表的意思,比如`1010`用`add`表示.因此`1010001100011001`表示为`add R3 R1 R9`.

将这种抽象符号进一步发展,我们不仅能够阅读符号表示,而且能实际的利用这些命令符号而不是二进制来编写程序,接下来,可以使用文本处理程序,将这些命令解析成其内容含义.生成对应的二进制表示码.因此符号也称为**汇编语言(assembly language)**,或者说成简单的汇编,而将汇编编译成二进制码的程序则称为**汇编编译器(assembler)**.

因为不同的计算机在 CPU 的操作方式,寄存器的数量和类型.以及汇编语法上各不相同,活像是巴别塔传说,每种计算机都有他们自己的晦涩语法,抛开差异性,所有机器语言都支持相似的通用命令集合,接下来会介绍.

### 命令 Commands

- **算数操作**和**逻辑操作** 计算机需要执行基本的算数操作(比如加法和减法),以及基本的布尔操作,.(比如按位取反,位移等等).这里给出一些例子,他们是使用典型的机器语言语法描述编写的:

```asm
ADD R1,R2,R3  // R2 <- R1+R3  其中R1,R2,R3是寄存器
ADD R1,R2,foo // R2 <- R1+foo 其中foo代表的意思是用户定义的标签foo所指向的内存单元的值
ADD R1,R2,R3  // R1 <- 对R1和R2进行安慰与(And)操作的结果
```

- **内存访问** 内存访问的命令分为两类

- 第一类,正如刚才看到的,算数命令和逻辑命令不仅允许操控寄存器,而且还可以操作特定的内存单元
- 所有计算机都会使用 load 和 store 命令,用来在寄存器和内存之间传递数据,这些访问命令可能会应用某些类型的寻址方式,并且指令中指定目标内存单元的地址,当然,不同的计算机有不同的寻址方式,下面三种大多数计算机都支持它的寻址方式:

- **直接寻址** 最常用的寻址方式,直接表示一个指定内存单元的地址,或者使用一个符号来代表

```asm
LOAD R1,67  // R1 <- Memory[67]
// 或者假设bar指向内存地址67,那么就有:
LOAD R1,bar // R1 <- Memory[67]
```

- **立即寻址** 这种寻址方式被用来加载常数 -- 也就是说,加载出来那些出现在指令代码里面的数值:我们直接将指令数据中的内容当做要操作的数据装入在指令代码里面的数值:我们直接用指令数据域中的内容当做要操作的数据装入寄存器,而不是直接将数值当做内存单元的地址:

```asm
LOADI R1,67 // R1 <- 67
```

- **间接寻址** 在这种寻址模式中,要访问的内存单元的地址没有直接出现在指令中,而是指令的内存单元中的内容代表目标内容单元的地址,这种寻址模式被用来处理**指针 Pointer**这种语言设施.比如一条高级语言命令 x=foo[j],这里的 foo 是数组变量,x 和 j 是整数变量.那么与这条命令等价的机器语言是什么?当数组 foo 在高级语言中被声明并被初始化时候,编译器分配一段连续的内存单元来保存这个数组数据.并用符号 foo 来指代该内存单元组的**基地址(base address)**.

于是当编译器后面遇到表示数组单元的符号(比如 foo[j])时候,将按照下步骤进行地址解析,首先,应该注意第 j 个数组入口是某个内存单元的物理地址,该地址相对于数组基地址的偏移量 j(为了简单期间,假设每个数组元素占用一个字).因此,表达式 foo[j]相关的地址可以容易的计算出来,只需要将 foo 加上 j 即可,在 c 中,`x=foo[j]`这样的命令也可以等价的表示成`x=*(foo+j)`,这里`*n`代表`Memory[n]`的值.被机器语言翻译的时候,这样的命令根据特定的汇编语言的语法,会产生如下代码

这个数组其实是从内存中从 foo 开始,开辟一段连续的内存空间,然后加载这个内存空间中第 j 个个数组,

```asm
// 将 x=foo[j] or x=*(foo+j) 翻译成汇编语言:
ADD R1,foo,j  // R1 <- foo+j        foo+j 赋值给R1
LOAD* R2,R1   // R2 <- Memory[R1]   从内存条中加载R1地址的值并且复制给R2
STR R2,x      // x  <- R2           将读取到的内存条中R1地址中的R2值赋值给x,即x=foo[j]
```

- **控制流程** 程序通常以线性方式,一个命令接着一个命令执行,偶尔也包含分支,执行其他地方的命令,分支能够实现好几种结果,包括**反复**(调到循环的初始位置),**有条件的执行**,如果布尔值是 false,则调到`if-then`这个地方,以及子程序调用,调到另一段代码的第一条命令处,为了支持这些程序结构,各种机器语言都可以有条件的或者无条件的跳转到程序指定的地址,在汇编语言中,程序中的位置也用一些符号表示.

#### 某高级语言实现 while

```js
while (R1 >= 0) {
  // 代码段1
}
// 代码段2
```

#### 底层实现

```asm
// while 循环结构的典型翻译
beginWhile
  JNG R1, endWhile  // If R1<0 goto endWhile
  // 这里放置代码段1的翻译内容
JMP beginWhile      // Goto beginWhile
endWhile:
  // 这里放置代码段2的翻译内容
```

高级和底层分支逻辑(branch logic).虽然不同语言的 goto commands 语法不同.但是基本思想是一样的

`if-then`语句之后的位置,以及**子程序调用**(subroutine calling, 调到另一端代码的第一条命令),为了支持这些程序结构,各种机器语言都可以有条件无条件跳转到程序指定的地址,在汇编语言中,程序的位置 也用一些特殊符号表示.

#### 无条件跳转

比如`JMP beginWhile`只是指定了跳转的目标地址,有条件跳转`JNG R1, endWhile`还必须要给出确定的布尔条件.

## Hack 机器语言规范

Hack 是一个基于冯诺依曼架构的 16-位计算机,由一个 CPU,两个独立的内存模块(instruction memory 指令内存和 data memory 数据内存),以及两个内存映射 I/O 设备(键盘显示器)组成

内存地址空间(Memory Address Space) Hack 程序员需要了解,有两个不同的地址空间,即指**令地址空间**,**数据地址空间**,也称之为数据内存.这两个内存区都是 16-位宽,有 15-位地址空间.这意味着两个内存可设的最大地址都是 32k 的 16-bit word.

**CPU** 仅仅只能执行存储在**指令内存**中的程序,指令内存是**只读**设备,程序通过某外部方法被加载到指令内存中,比如,可以在预先烧写了必要程序的 ROM 芯片中实现指令内存,要加载新程序,则要替换整个 ROM 芯片,要玩游戏时候,需要在游戏控制台中替换游戏卡片一样.

**寄存器** Hack 程序员要接触两个成为 D 和 A 的 16-位寄存器,这些寄存器能够被算数逻辑和逻辑指令显示的控制,比如`A=D-1` 或 `D!=A` 这里!表示 16 位的 Not 操作.D 仅用来存储数据值,A 既可以作为数据寄存器,也可作为地址寄存器.也就是说,根据指令的上下文含义.A 中的内容可被解释为数值或数据存储器中的地址,或者作为指令存储器中的地址.

首先,A 寄存器能够使"对数据内存(以后简称'内存')的直接存取变得十分容易.由于 hack 的指令是 16-位宽度,而对地址描述要用到 15 位,所以将操作码和地址都存放在同一条指令中是不可能的.因此,hack 语言的语法规定,内存的存取指令是对隐式内存地址"M"进行操作,比如 D=M+1.为了解析这个地址,规定 M 总是代表一个内存单元中的数值.

另外,身兼重任的 A 寄存器也被用来对指令存储器进行直接访问.与内存访问规则一致,Hack 的 jump 指令并不指定某个特定地址.其规定,任何 Jump 操作总是执行这样的跳转,即跳转到 A 寄存器所指令的指令,如此一来,若要执行操作 goto35,就要使用一条指令,将 A 的值置位 35,然后第二条指令就直接使用无需描述地址的 goto 指令.这个操作序列使得计算机在下一个时钟周期获取在 InstructionMemory[35]位置上的指令.

**示范** 因为 Hack 语言的语法是很容易理解的,我们就从一个例子开始说明,hack 语言中唯一需要解释的命令就是`@value`,这里 value 是可以是数值或者代表数值的符号,这个命令将特定的值寄存到 A 寄存器中,比如,如果 sum 代表地址内存 17,那么`@17`和@sum 都将具有一样的功能: `A<-17`.

回到这个例子:假设我们想要进行从 1+到 100,图 4.2 给出了 c 语言的算法和 hack 语言的汇编程序.

虽然 hack 语法比大多数机器语言更加好理解,但对于不太熟悉低级程序语言的读者,他仍然很晦涩.特别需要注意的是,每个涉及内存地址的操作需要两个 Hack 命令: 一个用来确定将要进行操作的内存单元地址,另一个用来描述进行的操作..Hack 语言正包含了两种指令,一个**地址指令**,也称之为 A-指令,另一个是`计算指令`,也称为`c-指令`,每种指令都有二进制表示和符号表示法.并且对计算机产生特定的作用

### A-指令

A-指令用来为 A 寄存器设置 15-位的值,

A-指令主要有三种不同的用途:
