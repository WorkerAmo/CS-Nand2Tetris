# 第 4 章 机器语言

我们可用结构化 的方式来描述计算机,给出他的硬件平台,然后解释它是如何由一些底层芯片构成的.也可以通过描述和演示机器语言的功能来抽象的描述计算机.事实上,要开始了解一个新的计算机系统,先去阅读一些机器语言编写的底层程序是十分必要的,这样不仅有助于了解如何通过程序来让计算机去执行正确的操作,还可以由此了解为什么其他硬件会按照某种特定的方式来设计,基于这种思想,本章集中讨论底层机器语言进行编程.

机器语言是一种特定的形式,用来对底层程序进行编码,从而形成一系列机器指令,应用这些指令进行编码,从而形成一系列机器指令.应用这些指令程序员可以命令处理器执行算数和逻辑操作.在内存中进行存取操作,让数据在寄存器之间传奇,验证布尔表达式的值等,高级语言的基本设计目标是通用性和较强性的的表达力,与高级语言相反,机器语言的设计目标是能直接运行在指定的硬件平台.

机器语言是整个计算机体系中意义最深奥的接口,他也是硬件和软件相接的中间线.借机器语言,程序员用符号指令表达的抽象思维被转换成执行在硅片上的物理操作.因此.可以将机器语言看做编程工作.也可以将其看做硬件平台内部不可分割的一部分.事实上,正如我们设计机器语言是为了使用给定的平台硬件一样,我们设计硬件平台是为了获解析并执行给定机器语言编写而成的机器语言编写而成的指令.

虽然大多数人不会用机器语言来编写程序,但是学习 底层编程是彻底理解计算机体系的必备条件,然而,你的发现是多么的激动人心,最复杂的软件系统,在底层其实是一串长基本指令,每条指令都描述了底层硬件上的一种极为简单原始的操作,还是那句话,要达到这样的理解程度,最好是手动写一些底层代码并让其在某硬件平台上面运行.

## 背景知识

本章为了对机器语言做一些一般性的描述,我们只需要集中讨论三个主要的抽象体:**处理器 processor**,**内存 memory**,以及一组**寄存器 registers**

- 机器语言,可被看做一种约定形式,他利用**处理器**和**寄存器**来操控**内存**

- **内存**,用于存储数据和指令的硬件设备.所有的内存具备相同的结构:一个连续固定宽度的单元序列,也称之为**字 word**或者内存单元,每个内存单元都是一个唯一的地址,因此对于独立的字代表一个数据项,或者说一个指令,他可以通过提供它的地址来描述.后面会用到`Memory[address]`或者`RAM[address]`,或者`M[address]`来表示内存.

- **处理器**,通常被成为 CPU 中央处理器(centeral Processing Unit),是执行一组固定基本操作的设备,这些操作通常包括算术操作和逻辑操作.内存存取操作`control operation`和控制操作`branching operation`.这些操作的对象是二进制数值,他们来自寄存器和指定的内存单元.操作的结果是处理器的输出.它可以存在寄存器内,也可以存在指定的内存单元.

- **寄存器** 内存访问的是相对较慢的操作,而且需要很长的指令格式(一个地址可能需要 32 位).基于这个原因,大多数处理器都有配一些寄存器.每个寄存器只存储一位.它挨着处理器,相当于处理器的一个高速本地内存.使得处理器能快速操控数据和指令.寄存器使得程序员能狗尽可能的使用内存访问命令.从而加速程序执行.

### 语言

机器语言是一系列编码指令,比如说在 16-位计算机上面典型的指令之一是`1010001100011001`,为了直到这个指令的意思,就必须直到语言的规则,也就是底层硬件平台的指令集和,比如这样的指令包含 4 个比特的位域(files):最左边的域是 CPU 的操作编码,剩下的三部分表示该操作的操作数,因此根据硬件平台上的机器语言语法,前面代表了`set R3 to R1+R9`

鉴于二进制编码相当晦涩,通常在机器语言中同时使用二进制编码和助记符.它的名字暗示了其代表的意思,比如`1010`用`add`表示.因此`1010001100011001`表示为`add R3 R1 R9`.

将这种抽象符号进一步发展,我们不仅能够阅读符号表示,而且能实际的利用这些命令符号而不是二进制来编写程序,接下来,可以使用文本处理程序,将这些命令解析成其内容含义.生成对应的二进制表示码.因此符号也称为**汇编语言(assembly language)**,或者说成简单的汇编,而将汇编编译成二进制码的程序则称为**汇编编译器(assembler)**.

因为不同的计算机在 CPU 的操作方式,寄存器的数量和类型.以及汇编语法上各不相同,活像是巴别塔传说,每种计算机都有他们自己的晦涩语法,抛开差异性,所有机器语言都支持相似的通用命令集合,接下来会介绍.

### 命令 Commands

- **算数操作**和**逻辑操作** 计算机需要执行基本的算数操作(比如加法和减法),以及基本的布尔操作,.(比如按位取反,位移等等).这里给出一些例子,他们是使用典型的机器语言语法描述编写的:

```asm
ADD R1,R2,R3  // R2 <- R1+R3  其中R1,R2,R3是寄存器
ADD R1,R2,foo // R2 <- R1+foo 其中foo代表的意思是用户定义的标签foo所指向的内存单元的值
ADD R1,R2,R3  // R1 <- 对R1和R2进行安慰与(And)操作的结果
```

- **内存访问** 内存访问的命令分为两类

- 第一类,正如刚才看到的,算数命令和逻辑命令不仅允许操控寄存器,而且还可以操作特定的内存单元
- 所有计算机都会使用 load 和 store 命令,用来在寄存器和内存之间传递数据,这些访问命令可能会应用某些类型的寻址方式,并且指令中指定目标内存单元的地址,当然,不同的计算机有不同的寻址方式,下面三种大多数计算机都支持它的寻址方式:

- **直接寻址** 最常用的寻址方式,直接表示一个指定内存单元的地址,或者使用一个符号来代表

```asm
LOAD R1,67  // R1 <- Memory[67]
// 或者假设bar指向内存地址67,那么就有:
LOAD R1,bar // R1 <- Memory[67]
```

- **立即寻址** 这种寻址方式被用来加载常数 -- 也就是说,加载出来那些出现在指令代码里面的数值:我们直接将指令数据中的内容当做要操作的数据装入在指令代码里面的数值:我们直接用指令数据域中的内容当做要操作的数据装入寄存器,而不是直接将数值当做内存单元的地址:

```asm
LOADI R1,67 // R1 <- 67
```

- **间接寻址** 在这种寻址模式中,要访问的内存单元的地址没有直接出现在指令中,而是指令的内存单元中的内容代表目标内容单元的地址,这种寻址模式被用来处理**指针 Pointer**这种语言设施.比如一条高级语言命令 x=foo[j],这里的 foo 是数组变量,x 和 j 是整数变量.那么与这条命令等价的机器语言是什么?当数组 foo 在高级语言中被声明并被初始化时候,编译器分配一段连续的内存单元来保存这个数组数据.并用符号 foo 来指代该内存单元组的**基地址(base address)**.

于是当编译器后面遇到表示数组单元的符号(比如 foo[j])时候,将按照下步骤进行地址解析,首先,应该注意第 j 个数组入口是某个内存单元的物理地址,该地址相对于数组基地址的偏移量 j(为了简单期间,假设每个数组元素占用一个字).因此,表达式 foo[j]相关的地址可以容易的计算出来,只需要将 foo 加上 j 即可,在 c 中,`x=foo[j]`这样的命令也可以等价的表示成`x=*(foo+j)`,这里`*n`代表`Memory[n]`的值.被机器语言翻译的时候,这样的命令根据特定的汇编语言的语法,会产生如下代码

这个数组其实是从内存中从 foo 开始,开辟一段连续的内存空间,然后加载这个内存空间中第 j 个个数组,

```asm
// 将 x=foo[j] or x=*(foo+j) 翻译成汇编语言:
ADD R1,foo,j  // R1 <- foo+j        foo+j 赋值给R1
LOAD* R2,R1   // R2 <- Memory[R1]   从内存条中加载R1地址的值并且复制给R2
STR R2,x      // x  <- R2           将读取到的内存条中R1地址中的R2值赋值给x,即x=foo[j]
```

- **控制流程** 程序通常以线性方式,一个命令接着一个命令执行,偶尔也包含分支,执行其他地方的命令,分支能够实现好几种结果,包括**反复**(调到循环的初始位置),**有条件的执行**,如果布尔值是 false,则调到`if-then`这个地方,以及子程序调用,调到另一段代码的第一条命令处,为了支持这些程序结构,各种机器语言都可以有条件的或者无条件的跳转到程序指定的地址,在汇编语言中,程序中的位置也用一些符号表示.

#### 某高级语言实现 while

```js
while (R1 >= 0) {
  // 代码段1
}
// 代码段2
```

#### 底层实现

```asm
// while 循环结构的典型翻译
beginWhile
  JNG R1, endWhile  // If R1<0 goto endWhile
  // 这里放置代码段1的翻译内容
JMP beginWhile      // Goto beginWhile
endWhile:
  // 这里放置代码段2的翻译内容
```

高级和底层分支逻辑(branch logic).虽然不同语言的 goto commands 语法不同.但是基本思想是一样的

`if-then`语句之后的位置,以及**子程序调用**(subroutine calling, 调到另一端代码的第一条命令),为了支持这些程序结构,各种机器语言都可以有条件无条件跳转到程序指定的地址,在汇编语言中,程序的位置 也用一些特殊符号表示.

#### 无条件跳转

比如`JMP beginWhile`只是指定了跳转的目标地址,有条件跳转`JNG R1, endWhile`还必须要给出确定的布尔条件.

## Hack 机器语言规范

Hack 是一个基于冯诺依曼架构的 16-位计算机,由一个 CPU,两个独立的内存模块(instruction memory 指令内存和 data memory 数据内存),以及两个内存映射 I/O 设备(键盘显示器)组成

内存地址空间(Memory Address Space) Hack 程序员需要了解,有两个不同的地址空间,即指**令地址空间**,**数据地址空间**,也称之为数据内存.这两个内存区都是 16-位宽,有 15-位地址空间.这意味着两个内存可设的最大地址都是 32k 的 16-bit word.

**CPU** 仅仅只能执行存储在**指令内存**中的程序,指令内存是**只读**设备,程序通过某外部方法被加载到指令内存中,比如,可以在预先烧写了必要程序的 ROM 芯片中实现指令内存,要加载新程序,则要替换整个 ROM 芯片,要玩游戏时候,需要在游戏控制台中替换游戏卡片一样.

**寄存器** Hack 程序员要接触两个成为 D 和 A 的 16-位寄存器,这些寄存器能够被算数逻辑和逻辑指令显示的控制,比如`A=D-1` 或 `D!=A` 这里!表示 16 位的 Not 操作.D 仅用来存储数据值,A 既可以作为数据寄存器,也可作为地址寄存器.也就是说,根据指令的上下文含义.A 中的内容可被解释为数值或数据存储器中的地址,或者作为指令存储器中的地址.

首先,A 寄存器能够使"对数据内存(以后简称'内存')的直接存取变得十分容易.由于 hack 的指令是 16-位宽度,而对地址描述要用到 15 位,所以将操作码和地址都存放在同一条指令中是不可能的.因此,hack 语言的语法规定,内存的存取指令是对隐式内存地址"M"进行操作,比如 D=M+1.为了解析这个地址,规定 M 总是代表一个内存单元中的数值.

另外,身兼重任的 A 寄存器也被用来对指令存储器进行直接访问.与内存访问规则一致,Hack 的 jump 指令并不指定某个特定地址.其规定,任何 Jump 操作总是执行这样的跳转,即跳转到 A 寄存器所指令的指令,如此一来,若要执行操作 goto35,就要使用一条指令,将 A 的值置位 35,然后第二条指令就直接使用无需描述地址的 goto 指令.这个操作序列使得计算机在下一个时钟周期获取在 InstructionMemory[35]位置上的指令.

**示范** 因为 Hack 语言的语法是很容易理解的,我们就从一个例子开始说明,hack 语言中唯一需要解释的命令就是`@value`,这里 value 是可以是数值或者代表数值的符号,这个命令将特定的值寄存到 A 寄存器中,比如,如果 sum 代表地址内存 17,那么`@17`和@sum 都将具有一样的功能: `A<-17`.

回到这个例子:假设我们想要进行从 1+到 100,图 4.2 给出了 c 语言的算法和 hack 语言的汇编程序.

虽然 hack 语法比大多数机器语言更加好理解,但对于不太熟悉低级程序语言的读者,他仍然很晦涩.特别需要注意的是,每个涉及内存地址的操作需要两个 Hack 命令: 一个用来确定将要进行操作的内存单元地址,另一个用来描述进行的操作..Hack 语言正包含了两种指令,一个**地址指令**,也称之为 A-指令,另一个是`计算指令`,也称为`c-指令`,每种指令都有二进制表示和符号表示法.并且对计算机产生特定的作用

### A-指令

A-指令用来为 A 寄存器设置 15-位的值,

A-指令主要有三种不同的用途:

- 首先,在程序控制下,它提供了唯一一种"常数输入计算机的方法"
- 其次,通过将目标数据内存单元的地址放入 A 寄存器,来为将对该内存单元进行操作的 C-指令提供必要条件,
- 其三,他通过跳转的目的地址放入 A 寄存器来为执行跳转到底 C-指令提供必要条件

#### c 语言例子

```c
// 1+...+100 累加
int i = 1;
int sum = 0;
While (i <= 100){
  sum+=i;
  i++;
}
```

#### hack 语言例子

```hack
// 1+...+100 累加
@i          // i 指代某个内存单元
M=11        // i = 1
@sum        // sum 指代某个内存单元
M=0         // sum = 0
(LOOP)
@i
D=M         // D=i
@100
D=D-A       // D=i-100
@END
D;JGT       // If (i-100)>0 goto END
@i
D=M         // D=i
@sum
M=D+M       // sum=sum+i
@i
M=M+1       // i=i+1
@LOOP
0;JMP       // Goto LOOP
(END)
@END
0;JMP
```

同一程序的 C 语言和汇编语言的版本,程序最后的无限循环是我门"结束"Hack 程序执行的标准方式

### C-指令

The C-Instruction

C-指令是 Hack 平台的重点,几乎包含所有要做的事情,指令代码的描述可以说是对以下三种问题的回答:

- (a)计算什么
- (b)将计算后的值存储到什么地方
- (c)下一步做什么

随着 A-指令一起,这些描述几乎决定了计算机所有可能的操作.

指令编码最左边起第一位为 1,则表示该指令是 C-指令,接着两位没有被使用,剩余的位构成了三个域,分别表示指令符号描述的三个部分.指令符号 dest = comp;jump 的整个语义可以如下表示,Comp 域高速 ALU 计算什么,Dest 域指明计算后的结果(ALU 的输出)将被存储到什么地方,Jump 域描述了转移条件,即接下来要取出并执行哪一条命令;

下面介绍这三个域的格式和语法.

**Computation 规范(计算规范)** Hack 的设计中,ALU 所执行的是一组固定的函数集,该函数集的功能实现了对寄存器 D,A,M(M 代表 Memory[A])的操作,计算函数指令的 comp 域由一个 a 位域(a-bits)和 6 个 c 位域(c-bits)

### 符号

汇编命令可以使用常数或符号来表示内存单元位置(地址).可以通过以下三种方式应用到汇编语言中:

- **预定义符号**: RAM 地址的一个特殊子集可以通过如下预定义符号使用
- **虚拟寄存器**
- **预定义指针**
- I/O 指针
- 标签符号
- 变量符号

### 输入/输出处理

Hack 平台能够连接两个外部设备:屏幕和键盘.两个设备与计算机平台的交互都是通过**内存映像**实现的,这意味着在屏幕上描绘像素是通过将二进制值写入与屏幕相关的内存段来实现.同样键盘输入是通过读取与键盘相关的内存单元来实现的.物理 I/O 设备和他们相对应的内存映像是通过连续的循环刷新来同步更新的.

**屏幕** Hack 计算机包括一个黑白屏幕,256 X 512 像素,屏幕内容由 RAM 基地地址为 16384(0x4000)的 8K 内存映射来表示.物理屏幕的每一行从屏幕左上角开始.在 RAM 中用 32 个连续的 16-位字来表示,

**键盘** Hack 计算机与物理键盘之间通过 RAM 基地址为 24576(0x6000)的单字内存映射进行交互.只要在键盘上敲击一个键,其对应的 16-位 ASCII 码值就出现在 RAM[24576];没有击键时,该内存单位的值就是 0,除了常用的 ASCII 码之外,Hack 键盘还可以识别图

### 语法规约和文件格式

- **二进制文件** 二进制文件由文本行组成,每行都是一连串的 16 个 0 和 1ASCII 字符,其对应一条单独的机器语言指令.文件中的所有行组成了机器语言程序.当机器语言程序被加载到计算机指令内存中,

- **汇编语言文件** 习惯上,汇编语言程序储存以 asm 扩展的文本文件里面,比入`Prog.asm`,汇编语言文件由文本行组成,每一行代表一跳**指令**或者一个符号定义:

- **指令** 1 条 A-指令和 C 指令

- **Symbol** 这条伪指令会让编译器吧 symbol 标签分配给程序中下一条命令被存储的内存单元地址.因为它不生成任何机器代码,称之为伪命令

- 常数和符号 常数必须是非负数且总数十进制表示.用户自定义的符号可以是任何字母,

- 注释

- 空格

- 大小写

### 观点

Hack 机器语言几乎是所有机器语言中最简单的一种,大多数计算机都有更多的指令,更多的数据类型,更多的寄存器,更多的指令格式,更多的寻址模式,然而,任何 Hack 机器语言不支持的功能都可以在软件中实现.比如乘法除法,这个可以在后面的操作系统中实现.

事实上,Hack 汇编代码典型的结构是 A-指令和 C-指令的连续交替,比如,@xxx 后面通常接着 D=D+M,@YYY 后面通常接着 0;JMP,等等,如果你觉得这种汇编方式太单调,可以在程序中使用一些更加友好**宏命令**,

**汇编编译器**在本章中提到了很多次,它是一个程序,负责将符号形式表达的汇编程序翻译成二进制代码编写的可执行程序.除此之外,他还负责管理汇编程序中所有系统符号,和用户定义符号,并在编译过程中以物理内存地址替换他们.

### 项目

- **目标** 初步了解机器语言底层编码,熟悉 Hack 计算机平台,在做本项目,你会逐渐熟悉汇编,同样也能形象的理解编译后的二进制码如何在硬件上执行.

- **资源** 在这个项目里你将会用到本书配套软件包中的两个工具: 汇编编译器,将用来 Hack 编译程序编译成二进制码,以及 CPI 仿真器,用来在虚拟的 Hack 平台上面运行二进制程序.

- **约定** 编写并测试下面两个程序,你的程序在 CPU 仿真器上执行时,应该会经由项目路径中的测试脚本的引领.

- **乘法程序** 该程序的输入值存储在 R0 和 R1 中(也就是内存的两个其实内存单元).程序就散 R0*R1 的值并将 其存入 R2,我们假设`R0>=0`, `R1>=0`, `R0*R1<32768`, 虽然这些条件程序不检测,但是作为程序设计者的你必须 保持他们成立,

- **I/O 处理程序**: 这个程序是一个无限循环,它侦测键盘输入,当任意键盘按入,程序将屏幕变黑,即将 black 写入每个像素.没有按下键盘的时候,屏幕应该被清屏,你以任何空间顺序来使得屏幕变黑和清屏,只要连续的按一个键足够长时间,屏幕就会全黑,长时间不按,屏幕清屏,这个程序检测脚本,只有通过对模拟屏幕的观察来检查执行结果.
