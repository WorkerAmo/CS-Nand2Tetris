# 第 7 章 虚拟机 I : 堆栈运算

本章节致力于构建典型的基于对象的高级语言编译器的初步步骤,

## 两个步骤

- 高级语言转换成中间代码(10,11 章节)
- 中间代码转换成机器语言(7,8 章节)

而中间语言运行在虚拟机中,增加代码的可移植性,而 VM 可以通过多种途径实现,通过软件翻译器,或者干脆吧 VM 程序翻译成某平台的机器语言.

虚拟器模型一般有一种语言,可以利用这种语言来编写 VM 程序,这里要介绍的 VM 语言包括 4 种类型的命令

1. 算数命令
2. 内存访问命令
3. 流程控制命令
4. 子程序调用命令

我们将这种语言分成 2 个部分,每一部分都会在独立的章节和项目里面介绍,本章节构成基本的 VM 编译器,他能将 VM 的算数命令和内存访问命令翻译成机器语言,在下一章节对这个基本的 VM 翻译器进行扩展,加入程序流程和子程序调用功能,由此构建完整的虚拟机,将作为 10,11 章节索要构建的编译器后端程序(backend).

虚拟机的出现,论证了计算机科学里面很多重要的思想.首先:将一台计算机在另一台计算机上面进行了仿真的概念,这是这个领域里面的基本思想之一.今年,`.net`和 java 都是这种架构.这些软件环境相当复杂,想要了解其中的内部结构,方法之一就是构建其 VM 内核的简单版本,正如我们现在做得东西一样.

这章节里面另一个重要的主题是`堆栈处理`.堆栈(stack)是基本且精良的数据结构,存在于很多计算机系统和算法中.由于本章介绍的 VM 是计划于堆栈(stack-based),因此 VM 也正为堆栈这个功能强大的数据结构提供了鲜活的事例.

## 7.1 背景知识

### 7.1.1 虚拟机范型

高级语言程序能够在目标计算机运行之前,他必须被翻译成计算机的机器语言,这个翻译工作也就叫做**编译(compilation)**,这是一个相当复杂的过程.通常,必须对任意给定的高级程序和其对应的机器语言编写专用的机器语言.

### 7.1.2 堆栈机模型

像很多程序语言一样,VM 语言包括算数操作,内存访问操作,程序流程控制操作和子程序调用工作.但是在选择中要考虑的关键是:**在 VM 操作中的操作数和结果应该驻留在哪里**,也许最干净利落的是将他放在**堆栈(stack)**数据结构里面.

在堆栈机(stack machine)模型中,算术命令将其操作数从堆栈顶弹出,并将结果从栈顶压入.其他命令将数据从对站定弹出.并转移到指定的内存单元,或者反向操作.

**基本堆栈操作** 核心就是先入先出.就像往干草堆上放东西一样,先放入先拿出.堆栈数据结构可以有很多方式实现.最简单的方式是创建一个数组和一个**堆栈指针**变量(sp, stack pointer),指向位于栈顶的元素.

高级语言一旦被编译成 VM 代码,就可以在任何平台上运行.

## 7.2 VM 规范详述, 第一部分

### 7.2.1 概述

虚拟机是**基于堆栈(stack-based)**的:所有的操作都在堆栈上完成,它也是**基于函数(function-based)**的:一个完整的,应用 VM 语言编写的 VM 程序,由若干个成为**函数**的程序单元组成,这些函数使用 VM 程序编写,每个函数都有自己独立的代码,并被独立的处理,VM 语言使用单一的 16-位数据类型,他能够被表示整数,布尔类型,或者指针,该语言也包含 4 种类型的命令

- **算数命令** 在堆栈上执行算术和逻辑操作
- **存储器存取命令** 在堆栈和虚拟内存单元之间转移数据
- **程序流程命令** 使用条件分支操作和无条件分值操作变得容易
- **函数调用命令** 调用函数并返回回调用处(即函数调用指令的下一条指令地址)

```asm
// d=(2-x)*(y+5)  假设x,y初始值5,9
push 2  // 将2推入堆栈,SP(stack pointer)指针指向2上一个指针
push x  // 将x即5推入栈
sub     // 相减
push y  // 将y即9推入栈
push 5  // 将5推入栈
add     // 最后两个栈的数字相加
mult    // 最后两个栈的数字相乘
pop d   // 推出到变量d上面.
```

```asm
// if (x<7) or (y=8)  假定x=12,y=8
push x    // push x=8 into stack
push 7    // push 7 into  stack
lt        // stack's last two number it to  comparison each other and return true/false
push y    // push y=8 into stack
push 8    // push 8 into stack
eq        // campare stack last two number y=8? return true/false
or        // compare stack's last two number false or true logic gates
```

构建虚拟机是一件复杂的事情,因此将他分成两个阶段.本章节介绍**算术命令**和**内存访问**命令,构建仅实现这两种命令的基本 VM 翻译器.下一章节会详细介绍流程控制和函数调用命令,然后我们要用构建好的翻译器扩展词一个包含这两种命令的虚拟机/

**程序和命令结构** VM 程序是由一个或者多个扩展名为.vm 的文件构成的集合,而每个程序又包含了一个或者多个函数,从编译的角度来看,这些结构分别于面向对象编程语言中的 program, class , method 的概念相对应.

在.vm 文件中,每一行 vm 命令,按照下面形式来书写:

- 命令 (比如, add)
- 命令 参数 (比如, goto loop)
- 命令 参数 1 参数 2 (比如, push local 3)

参数与参数之间,参数与命令之间必须使用空格分离,空格的个数可以是任意的,每一行尾部可以添加以`\\`开头的注释,他不会被程序执行,程序中允许出现空行,他同样不会被执行

### 7.2.2 算数命令和逻辑命令

VM 语言中有 9 个面向堆栈的算术命令和逻辑命令.其中的 7 个命令是二元的:他们从堆栈中弹出两个元素,在 其上执行二元函数操作,然后将结果压回堆栈.剩下的两个命令是一元的,只从堆栈中弹出一个元素,在其上执行一元函数操作,然后将结果压回堆栈.可以看到每个命令仅会用操作结果来取代它的操作数.而堆栈的其他部分没有影响.

### 7.2.3 内存访问命令

add x+y
sub x-y
neg -y
eq x=y
gt x>y
lt x<y
and x&y
or x|y
not !x

在本章节前面介绍,内存访问命令使用伪命令 pop 和 push 来表示,这里符号 x 代表在某个全局内存中的一个独立的存储单元.然而正规来说,VM 操纵 8 个独立的**虚拟内存段**,

内存访问命令

- push segment index 将 segment[index]的值压入堆栈.
- pop segment idnex 将栈顶元素弹出然后存入 segment[index]

|   段名    |                             功能                             |                                说明                                |
| :-------: | :----------------------------------------------------------: | :----------------------------------------------------------------: |
| argument  |                        存储函数的参数                        |             当进入函数时候,由 VM 实现机制进行自动分配              |
|   local   |                      存储函数的局部变量                      |      当进入函数时候,由 VM 实现机制进行动态分配并被初始化为 0       |
|  static   |          存储同一个 VM 文件中所有函数共享的静态变量          | 由 VM 实现机制为每个.vm 文件进行分配; 被.vm 文件中国的所有函数共用 |
| constant  |          所包含的所有常数的伪段,常数的范围 0..32767          |       由 VM 实现机制来模拟;该段对于程序中所有函数都是可见的        |
| this that |   通用段,能够与堆中不同区域相对应来满足各种程序编写的需求    |          任何 VM 函数可以使用这两个段来操纵堆中指定的区域          |
|  pointer  | 该段由两个内存单元组成, 用来保存 this 和 that 两个段的基地址 |          被任何 VM 函数用于任何用途,被程序中所有函数共享           |

**堆栈 stack** 考虑两条连续的命令语句 push arugment 2 和 pop local 1, 这个在前面提及过.这样的 VM 操作的工作内存就是**堆栈**,数据值并不是简单的直接从一个单元跳到另一个单元,而是必须经过堆栈中转,尽管堆栈是 VM 结构中的核心绝色,但是在 VM 语言中从未显示的体现他的功能.

**堆 heap** 处在 VM 后端的另一个数据结构就是堆, 堆是 RAM 区域的名字. 用来存储对象和数组数据,这些对象和数组,能够通过 VM 命令来模拟操纵.我们马上就将会看到.

### 7.2.4 程序流程控制命令和函数调用命令

VM 提供 6 个附加命令,将会在下一章节中详细的讨论,为了完整期间,这些命令在下面列了出来.

**程序流程控制命令:**

```asm
label symbol    // 标签声明
goto symbol     // 无条件分支
if-goto symbol  // 条件分支
```

**函数调用命令:**

```asm
function 函数名 nLocals // 函数声明,指明函数的本地变量个数
call 函数名 nArgs       // 调用函数, 指明函数的参数的个数
return                  // 将程序控制权返回给调用者
```

这些命令中, 函数名字是组付出, nLocals 和 nArgs 都是非负整数

### 7.2.5 Jack-VM-Hack 平台中的程序元素

让我们采用自顶向下的视角,来审视典型的高级程序在完整的编译过程中所涉及的所有程序元素,一次来结束对VM规范的第一部分的阐述,(jack是简单的类Java语言,在第九章介绍),每个Jack类包含一个人或者多个函数.

**数组处理** 数组实际上就是一组有索引的对象集合. 假设高级语言创建了名为bar的由10个整数组成的数组,然后填入了10个数字,现在假定数组的基地址已经被映射到RAM地址4315处.假设现在程序想要执行命令`bar[2]=19`.那么如何在VM层上实现这个操作呢?

在C语言中年,这样的操作可以被描述为`*(bar+2)=19`,意思是**将RAM中地址为bar+2的位置赋予值19**,如图所示,的VM代码呢,这个转化过程在11章节介绍.

**对象处理** 高级语言的程序员将对象看成了封装了数据(由成员字段fileds;或者属性即properties组成)和相关代码的实体.然而从本质上说,每个对象实例(object instance)的数据是在RAM上面被序列化(serialized)成一串数字,这串数字代表对象中各个字段的值.因此,对象的地基处理和数组的低级处理很相似.

例如,考虑一个动画程序,该程序在屏幕上弹球,假设每个球对象被整数数字段x,y,radius和color来描述,而且程序创建了该对象并且命名为b,那么这个对象在计算机内部形式将是如何呢?

存在RAM里面,操作系统会去寻找一个足够大的RAM空间并且分配.
