# 第 7 章 虚拟机 I : 堆栈运算

本章节致力于构建典型的基于对象的高级语言编译器的初步步骤,

## 两个步骤

- 高级语言转换成中间代码(10,11 章节)
- 中间代码转换成机器语言(7,8 章节)

而中间语言运行在虚拟机中,增加代码的可移植性,而 VM 可以通过多种途径实现,通过软件翻译器,或者干脆吧 VM 程序翻译成某平台的机器语言.

虚拟器模型一般有一种语言,可以利用这种语言来编写 VM 程序,这里要介绍的 VM 语言包括 4 种类型的命令

1. 算数命令
2. 内存访问命令
3. 流程控制命令
4. 子程序调用命令

我们将这种语言分成 2 个部分,每一部分都会在独立的章节和项目里面介绍,本章节构成基本的 VM 编译器,他能将 VM 的算数命令和内存访问命令翻译成机器语言,在下一章节对这个基本的 VM 翻译器进行扩展,加入程序流程和子程序调用功能,由此构建完整的虚拟机,将作为 10,11 章节索要构建的编译器后端程序(backend).

虚拟机的出现,论证了计算机科学里面很多重要的思想.首先:将一台计算机在另一台计算机上面进行了仿真的概念,这是这个领域里面的基本思想之一.今年,`.net`和 java 都是这种架构.这些软件环境相当复杂,想要了解其中的内部结构,方法之一就是构建其 VM 内核的简单版本,正如我们现在做得东西一样.

这章节里面另一个重要的主题是`堆栈处理`.堆栈(stack)是基本且精良的数据结构,存在于很多计算机系统和算法中.由于本章介绍的 VM 是计划于堆栈(stack-based),因此 VM 也正为堆栈这个功能强大的数据结构提供了鲜活的事例.

## 7.1 背景知识

### 7.1.1 虚拟机范型

高级语言程序能够在目标计算机运行之前,他必须被翻译成计算机的机器语言,这个翻译工作也就叫做**编译(compilation)**,这是一个相当复杂的过程.通常,必须对任意给定的高级程序和其对应的机器语言编写专用的机器语言.

### 7.1.2 堆栈机模型

像很多程序语言一样,VM 语言包括算数操作,内存访问操作,程序流程控制操作和子程序调用工作.但是在选择中要考虑的关键是:**在 VM 操作中的操作数和结果应该驻留在哪里**,也许最干净利落的是将他放在**堆栈(stack)**数据结构里面.

在堆栈机(stack machine)模型中,算术命令将其操作数从堆栈顶弹出,并将结果从栈顶压入.其他命令将数据从对站定弹出.并转移到指定的内存单元,或者反向操作.

**基本堆栈操作** 核心就是先入先出.就像往干草堆上放东西一样,先放入先拿出.堆栈数据结构可以有很多方式实现.最简单的方式是创建一个数组和一个**堆栈指针**变量(sp, stack pointer),指向位于栈顶的元素.

高级语言一旦被编译成 VM 代码,就可以在任何平台上运行.

## 7.2 VM 规范详述, 第一部分

### 7.2.1 概述

虚拟机是**基于堆栈(stack-based)**的:所有的操作都在堆栈上完成,它也是**基于函数(function-based)**的:一个完整的,应用 VM 语言编写的 VM 程序,由若干个成为**函数**的程序单元组成,这些函数使用 VM 程序编写,每个函数都有自己独立的代码,并被独立的处理,VM 语言使用单一的 16-位数据类型,他能够被表示整数,布尔类型,或者指针,该语言也包含 4 种类型的命令

- **算数命令** 在堆栈上执行算术和逻辑操作
- **存储器存取命令** 在堆栈和虚拟内存单元之间转移数据
- **程序流程命令** 使用条件分支操作和无条件分值操作变得容易
- **函数调用命令** 调用函数并返回回调用处(即函数调用指令的下一条指令地址)

```asm
// d=(2-x)*(y+5)  假设x,y初始值5,9
push 2  // 将2推入堆栈,SP(stack pointer)指针指向2上一个指针
push x  // 将x即5推入栈
sub     // 相减
push y  // 将y即9推入栈
push 5  // 将5推入栈
add     // 最后两个栈的数字相加
mult    // 最后两个栈的数字相乘
pop d   // 推出到变量d上面.
```

```asm
// if (x<7) or (y=8)  假定x=12,y=8
push x    // push x=8 into stack
push 7    // push 7 into  stack
lt        // stack's last two number it to  comparison each other and return true/false
push y    // push y=8 into stack
push 8    // push 8 into stack
eq        // campare stack last two number y=8? return true/false
or        // compare stack's last two number false or true logic gates
```

构建虚拟机是一件复杂的事情,因此将他分成两个阶段.本章节介绍**算术命令**和**内存访问**命令,构建仅实现这两种命令的基本 VM 翻译器.下一章节会详细介绍流程控制和函数调用命令,然后我们要用构建好的翻译器扩展词一个包含这两种命令的虚拟机/

**程序和命令结构** VM 程序是由一个或者多个扩展名为.vm 的文件构成的集合,而每个程序又包含了一个或者多个函数,从编译的角度来看,这些结构分别于面向对象编程语言中的 program, class , method 的概念相对应.

在.vm 文件中,每一行 vm 命令,按照下面形式来书写:

- 命令 (比如, add)
- 命令 参数 (比如, goto loop)
- 命令 参数 1 参数 2 (比如, push local 3)

参数与参数之间,参数与命令之间必须使用空格分离,空格的个数可以是任意的,每一行尾部可以添加以`\\`开头的注释,他不会被程序执行,程序中允许出现空行,他同样不会被执行

### 7.2.2 算数命令和逻辑命令

VM 语言中有 9 个面向堆栈的算术命令和逻辑命令.其中的 7 个命令是二元的:他们从堆栈中弹出两个元素,在 其上执行二元函数操作,然后将结果压回堆栈.剩下的两个命令是一元的,只从堆栈中弹出一个元素,在其上执行一元函数操作,然后将结果压回堆栈.可以看到每个命令仅会用操作结果来取代它的操作数.而堆栈的其他部分没有影响.

### 7.2.3 内存访问命令

add x+y
sub x-y
neg -y
eq x=y
gt x>y
lt x<y
and x&y
or x|y
not !x

在本章节前面介绍,内存访问命令使用伪命令 pop 和 push 来表示,这里符号 x 代表在某个全局内存中的一个独立的存储单元.然而正规来说,VM 操纵 8 个独立的**虚拟内存段**,

内存访问命令

- push segment index 将 segment[index]的值压入堆栈.
- pop segment idnex 将栈顶元素弹出然后存入 segment[index]

|   段名    |                             功能                             |                                说明                                |
| :-------: | :----------------------------------------------------------: | :----------------------------------------------------------------: |
| argument  |                        存储函数的参数                        |             当进入函数时候,由 VM 实现机制进行自动分配              |
|   local   |                      存储函数的局部变量                      |      当进入函数时候,由 VM 实现机制进行动态分配并被初始化为 0       |
|  static   |          存储同一个 VM 文件中所有函数共享的静态变量          | 由 VM 实现机制为每个.vm 文件进行分配; 被.vm 文件中国的所有函数共用 |
| constant  |          所包含的所有常数的伪段,常数的范围 0..32767          |       由 VM 实现机制来模拟;该段对于程序中所有函数都是可见的        |
| this that |   通用段,能够与堆中不同区域相对应来满足各种程序编写的需求    |          任何 VM 函数可以使用这两个段来操纵堆中指定的区域          |
|  pointer  | 该段由两个内存单元组成, 用来保存 this 和 that 两个段的基地址 |          被任何 VM 函数用于任何用途,被程序中所有函数共享           |

**堆栈 stack** 考虑两条连续的命令语句 push arugment 2 和 pop local 1, 这个在前面提及过.这样的 VM 操作的工作内存就是**堆栈**,数据值并不是简单的直接从一个单元跳到另一个单元,而是必须经过堆栈中转,尽管堆栈是 VM 结构中的核心绝色,但是在 VM 语言中从未显示的体现他的功能.

**堆 heap** 处在 VM 后端的另一个数据结构就是堆, 堆是 RAM 区域的名字. 用来存储对象和数组数据,这些对象和数组,能够通过 VM 命令来模拟操纵.我们马上就将会看到.

### 7.2.4 程序流程控制命令和函数调用命令

VM 提供 6 个附加命令,将会在下一章节中详细的讨论,为了完整期间,这些命令在下面列了出来.

**程序流程控制命令:**

```asm
label symbol    // 标签声明
goto symbol     // 无条件分支
if-goto symbol  // 条件分支
```

**函数调用命令:**

```asm
function 函数名 nLocals // 函数声明,指明函数的本地变量个数
call 函数名 nArgs       // 调用函数, 指明函数的参数的个数
return                  // 将程序控制权返回给调用者
```

这些命令中, 函数名字是组付出, nLocals 和 nArgs 都是非负整数

### 7.2.5 Jack-VM-Hack 平台中的程序元素

让我们采用自顶向下的视角,来审视典型的高级程序在完整的编译过程中所涉及的所有程序元素,一次来结束对 VM 规范的第一部分的阐述,(jack 是简单的类 Java 语言,在第九章介绍),每个 Jack 类包含一个人或者多个函数.

**数组处理** 数组实际上就是一组有索引的对象集合. 假设高级语言创建了名为 bar 的由 10 个整数组成的数组,然后填入了 10 个数字,现在假定数组的基地址已经被映射到 RAM 地址 4315 处.假设现在程序想要执行命令`bar[2]=19`.那么如何在 VM 层上实现这个操作呢?

在 C 语言中年,这样的操作可以被描述为`*(bar+2)=19`,意思是**将 RAM 中地址为 bar+2 的位置赋予值 19**,如图所示,的 VM 代码呢,这个转化过程在 11 章节介绍.

**对象处理** 高级语言的程序员将对象看成了封装了数据(由成员字段 fileds;或者属性即 properties 组成)和相关代码的实体.然而从本质上说,每个对象实例(object instance)的数据是在 RAM 上面被序列化(serialized)成一串数字,这串数字代表对象中各个字段的值.因此,对象的地基处理和数组的低级处理很相似.

例如,考虑一个动画程序,该程序在屏幕上弹球,假设每个球对象被整数数字段 x,y,radius 和 color 来描述,而且程序创建了该对象并且命名为 b,那么这个对象在计算机内部形式将是如何呢?

存在 RAM 里面,操作系统会去寻找一个足够大的 RAM 空间并且分配.

## 7.3 实现

### RAM 用法

Ram 内存由 32 个 16-位字组成,RAM 分配规律如下

|  RAM 地址   |             功用              |
| :---------: | :---------------------------: |
|    0-15     |        16 个虚拟内存器        |
|   16-255    | VM 程序所有 VM 函数的静态变量 |
|  256-2047   |              栈               |
| 2048-16383  |             堆栈              |
| 16384-24575 |         内存映像 I/O          |

### R0-R15

|     寄存器      | 名称 |              功用               |
| :-------------: | :--: | :-----------------------------: |
|     RAM[0]      |  SP  |  栈指针:指向栈中下一个最顶位置  |
|     RAM[1]      | LCL  | 指向当前 VM 函数 local 段的基址 |
|     RAM[2]      | ARG  | 指向 VM 函数 argument 段的基址  |
|     RAM[3]      | THIS | 指向当前 this 段(在堆中的基址)  |
|     RAM[4]      | THAT | 指向当前 that 段(在堆中的基址)  |
| RAM[5]-RAM[12]  |      |       保存 temp 段的内容        |
| RAM[13]-RAM[15] |      |   可被 VM 实现用作通用寄存器    |

### 内存段映射

local,argument, this, that: 每一个这样的段都被直接映射到 RAM;通过专用的寄存器(分别位 LCL,ARG,THIS,THAT)来保存,其物理基地址,就可以维持其在 RAM 中的位置.如此一来,对这些段的第 i 个数据项的访问,应被翻译成`获取RAM中地址为(base+i)`的值的汇编代码,这里 base 是存储在各段专有寄存器中的当前值.

pointer, temp: 这些段被直接映射在 RAM 中的一个固定区域上.pointer 段被映射在 RAM 位置 3-4(也称之为 THISheTHAT)上,temp 段被映射在 RAM 位置 R5-R12 位置上,因此访问 point i 应该被翻译成 RAM 位置 i+3 的汇编代码,

Constant: 这个段是真正虚拟的,因为他不占用目标平台上的任何物理存储空间.VM 通过实现简单的提供常数 i 来处理任何 VM 对`<constant i>`的访问.

static: 根据 Hack 机器语言规范,在汇编程序中每遇到一个新的符号时,编译器就为其分配一个新的 RAM 单元,从地址 16 处开始.利用这个规定,使用汇编语言符号 f.j 来表示来表示 VM 文件 f 中每个静态变量数字 j.例如,假设文件`xxx.vm`包含命令`push static 3`,该命令被翻译成 Hack 汇编命令`@xxx.3`和`D=M`,接下来的汇编代码将 D 的值压入堆栈.该 static 段的实现方式有点技巧诡异.

### 汇编语言符号

下面重新给出了所有在 VM 实现机制中使用的汇编语言符号,他们符合标准映射规范.

|          符号           |                                                            功用                                                            |
| :---------------------: | :------------------------------------------------------------------------------------------------------------------------: |
| SP,LCL, ARG, THIS, THAT |                            这些预定义的符号分别指向栈顶以及 local,argument,this,that 各段的基址                            |
|         R13-R15         |                                           这些预定义符号可用于任何目的,是通用的                                            |
|       xxx.j 符号        | 文件 xxx.vm 中的每个静态变量 j 被翻译为汇编符号 xxx.j,在后续汇编过程中.这些符号变化变量将会由 Hack 编译器为其分配 RAM 空间 |
|       控制流符号        |                        VM 命令 function, call, label 的实现涉及到生成特殊的标签符号,将在第八章详述                         |

### 7.3.2 关于 VM 设计实现的建议

VM 翻译器应该接受一个简单的单一命令行参数,如下:
`Prompt> Vmtranslator source`

这里 source 是 xxx.vm 文件的文件名(必须有扩展名)或者是包含一个或者多个.vm 文件的路径名称(不能带扩展名),其实就是路径映射规则,这个稍后自己调试.

### 7.3.3 程序结构

本书计划采用 parser 和 codewriter 来实现 VM 翻译器,

**主程序** 本程序应该构造一个 parser 和一个 codewriter,Parser 用来解析 VM 输入文件;CodeWriter 用来生成 hack 汇编代码写入响应的输入文件.asm 文件中.另外,主程序应该持续输入文件中的每一条命令并为其生成对应的汇编代码.

如果程序的参数是路径名称而不是文件名称,那么主程序应该处理该路径下的所有.vm 程序.那么他应该使用独立的 parser 来处理每个输入文件.以及单一的 codewriter 来处理输出.

### 观点

本章开发了高级语言的编译器,遵循现代软件工程实践的经验,采用两层模型进行开发

### 项目

本章节阐述的是的如何构建本章节所描述的 VM 翻译器.,下一章节会将本章节的编译器做进一步功能扩展,最终形成完整的虚拟机实现,开始之前,需要说明两点,第一,7.2.6 章节的内容与本项目无关,第二.VM 翻译器是用来生成 hack 汇编代码,因此你可能有必要复习一下 Hack 汇编语言的内容.

**目标** 构建 VM 编译器的第一个部分,包括堆栈运算和 VM 语言的内存访问命令

**资源** 需要两种工具: 实现 VM 翻译器所需的编程语言,以及本书配套的 CPU 仿真器.该 CPU 仿真器可以执行 VM 翻译器所生成的机器代码---这是一种测试 VM 翻译器的间接方法.另一种好用的工具是与本书配套的可视化 VM 仿真器,可以在构建自己的 VM 实现之前,使用可视化 VM 仿真器来了解 VM 实现的工作原理,关于可视化仿真器的更多信息,参考 VM 仿真器的教程

**约定** 按照 VM 规范第一部分以及 Hack 平台标准 VM 映射第一部分的描述,编写 VM-to-Hack 的翻译器,然后使用该翻译器来提供这个 VM 程序产生对应的 Hack 汇编语言程序,产生对应的 hack 编程语言程序,用 CPU 仿真器来执行这些声称出来的汇编程序,应该符合测试脚本以及比较文件所要求的结果

### 建议的实现步骤

建议采用两个阶段来完成构建,这样你就能以递增的方式,利用提供的测试程序对你的实现进行单元测试.

**第一节阶段: 堆栈运算命令** VN 翻译器的首版应该实现 VM 语言的 9 个堆栈命令运算逻辑命令,以及`push constant x`命令(该命令有助于测试实现的 9 个命令).注意, `push constant x`命令是通用 push 命令的特殊版本;其中第一个参数是常量,德尔格参数是十进制常量.

**第二个阶段: 内存访问命令** 翻译器的第二版本应该包含 VM 语言中 push 和 pop 命令的完整实现.能够处理所有 8 个内存端,建议将本阶段细分为如下几个步骤:

1. 已经能够处理 constant 段;
2. 然后,处理 local 段, argument 段, this 段.that 段;
3. 然后,处理 pointer 段和 temp 段,即要能狗允许修改 this 段和 that 段的基地址
4. 最后,处理 static 段.

**测试程序**
下面 5 个 vm 程序能够分别使用上述各个阶段进行单元测试.

第一阶段: 堆栈运算

- SimpleAdd: 压入并相加两个常量.
- StackTest: 执行一系列堆栈上的运算和逻辑操作.

第二阶段: 内存访问

- BasicTest: 使用虚拟内存段执行 pop 和 push 操作
- PointerTest: 使用 pointer 段,this 段,that 段,执行 pop 和 push 操作
- StaticTest: 使用 Statci 段执行 pop 和 push 操作

对于每个程序 xxx,我们提供了 4 个文件,首先是 vm 文件,测试脚本,cmp 对比文件

**初始化** 为了运行翻译过的 VM 程序,vm 程序必须包含一段启动代码,以便于让 VM 实现在宿主平台上启动执行,另外,为了保证 VM 代码正常运行,VM 实现虚拟内存段的基地址映射到选定的 RAM 位置.由于启动代码和虚拟内存段的初始化这两件事在下一个项目中才会完成.因此这里遇到的困难是我们所需要现成可用的初始化操作.
