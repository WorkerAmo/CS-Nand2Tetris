# 第 8 章 虚拟机 II : 程序控制

本章节致力于介绍堆栈的设计原理,以及它是如何处理过程化语言,或者面向对象的语言的嵌套子程序

## 背景知识

高级语言允许描述这样的表达式`x=-b+sqrt(power(b,2)-4*a*c)`来表示,他几乎和实际表达式差不多,高级语言支持这种表达式来源于它的三种语言原则.

- 高级语言允许在程序中根据自由定义入 sqrt 和 power 这样的高级操作(函数)
- 高级语言允许自由调用这些子函数,就像使用一些如+/-这样的基本操作
- 高级语言允许假设每个被调用的子程序都被执行,并且随着子程序的结束,程序的控制权顺利返回

高级语言所具有的这些能够将表达式自由组合的能力,使得我们可以编写更加抽象的代码,让我们能把主要精力放在算法的思想上,而不是机器上,当然高级的语言抽象级别越高,在底层要做的工作就越多,特别的是,必须在底层控制子程序和子程序调用者(执行注入 sqrt 和 power 的系统定义的用户定义操作的程序单元)之间的相互影响,对于在运行期的每个子程序调用,底层必须处理下面的一些细节

- 将参数从调用者传递给被调用者,
- 在跳转并执行被调用之前,必须保存调用者的状态/
- 为被调用者使用局部变量分配空间
- 跳转并执行被调用者
- 被调用者的运行结果返回给调用者.
- 在从被调用者的运行之前,回收其使用的内存空间
- 回复调用者的状态
- 返回调用语句之后的下一条语句继续执行.

要考虑这些繁琐的事情本身就很头疼疼好在编译器把高级语言从程序员从中解放出来,事实上**堆栈机**就很适合处理这些任务.

本章节剩余内容将是描述**程序控制流**命令和**子程序调用**是如何在堆栈机上面实现的,我们先介绍控制流命令的实现.然后再介绍复杂的子程序调用.

子程序通常使用局部变量 local variables 进行临时存储,在子程序的生命周期中,也就是从子程序开始执行到 return 命令位置,必须为这些局部变量分配内存.子程序返回时候,被这些局部变量占用的内存将被释放.当子程序被任意嵌套时候,子程序可以调用另一个子程序,这将会变得十分复杂,同时还有递归调用自身.因此子程序实现机制是后进先出的堆模式.因此当子程序 xxx 调用子程序 yyy 的时候,可以将 xxx 的环境变量压入堆栈中,然后执行 yyy,yyy 返回后,再将 xxx 的环境变量从堆栈中弹出(恢复),如果没有特殊的情况下,就执行 xxx.

我们在概念上使用帧(frame)来代表子程序的局部变量的集合,它包括子程序的参数,工作堆栈和运行过程中所使用的内存段,现在开始,堆栈(stack)开始指代**全局堆栈**,这是由当前子程序的帧,和所有正在等待该子程序返回其他子程序的帧所构成的内存区,这两个不同的堆栈概念是紧密相关的,因为当前子程序的工作堆栈位于全局堆栈的顶部.

在 call xxx 操作的底层实现中,先将调用者的帧保存到堆栈中,然后为子程序 xxx 的局部变量分配堆栈空间,最后跳到子程序 xx 开始执行其代码,最后一部大跳转,并不难实现,因为目标子程序的名字在 call 命令中已经被指定了.这样的调用过程中可以将这个目标程序名解析成一个内存地址,然后跳转到地址为基址的代码段,(该代码段就是子程序的代码段)开始执行.而通过 return 命令从子程序中返回的过程却暗藏玄机,因为命令中并未指定返回地址,事实上,在所有调用子程序的过程中,调用者的返回地址并没有显式的给出,比如因为想`power(x,y)`或者`sqrt(x)`这样的子程序可以被任何调用者调用,那么它的代码中就不可能给出具体的返回地址,所以,return 命令应该按如下方式来解释:它将程序的执行重定向到调用语句 call 命令的下一条命令所在的内存地址,(无论这条命令的内存地址位置在哪),即称之为**返回地址**(return address).

基于堆栈调用的返回实现过程如图 8.3 所示,我们调用 call xxx 指令执行调用操作时, 应该知道准确的返回地址:指令 call xxx 的下一条指令的内存地址,因此,我们将该指令内存地址作为返回地址压入堆栈保存,然后去执行子程序.当我门最终遇到 return 命令时候,我们就将先前保存在对炸某种的返回的地址弹出来,然后只用简单的 goto 命令跳转到这个地址就可以了,换句话说,这就是返回地址也可以保存在调用者的帧里面.

## VM 规范详述 II

### 程序控制命令

VM 语言的三种形式的程序控制命令流:

- **label _label_** 该命令标记程序中某条指令的位置,在程序中的跳转指令就只能跳转到被 **label _label_** 所标记的位置,label 标签所指示的代码段范围就是程序中定义的函数体,label 可以是任意字母,数字,下划线和冒号:组成的组付出,但不能是数字开头.
- **goto _label_** 该命令执行**条件跳转**操作.首先,将布尔表达式的运算结果从堆栈顶段弹出,如果该值非 0,那么程序就跳转到 label 标志的位置继续进行;否则,继续执行程序中的下一条命令.跳转的目的地址必须是位域同一个函数内.

### 函数调用命令 Function Calling Commands

不同的高级语言对于程序单元(program units)概念采用不同的名称, 包括 函数 function, 过程 procedure, 方法 method, 以及子程序 subroutine.在整个便已模型中, 每个高级程序单元都被翻译成 VM 函数.或者简称**函数**.

函数的名称是一个全局量,可以是任意字母,数字,下划线,点,以及冒号组成的字符串, 但不能以数字开头,(如果在高级语言的 Foo 类中定义函数 bar,那么该函数应该经过编译翻译成为对应的名为 Foo.bar 的 function).函数的名称的使用范围是全局的,即所有文件中的所有函数都可以通过这个全局名称相互调用.

VM 语言的是那种函数相关的命令:

- function _f_ _n_ 一段函数名为 f 的代码,该函数有 n 个参数
- call _f_ _n_ 调用函数 f,其中 m 个参数已经被调用者压入调用栈;
- return 返回到调用者.

### 函数调用协议 The Function Calling Protocol

调用函数和从函数返回这两个操作可以用两个不同的角度来看. 即**调用者**和**被调用者**

#### 调用者角度

- 在调用函数之前,调用者必须将必要的参数压入堆栈;
- 接着,调用者使用 call 命令来调用函数;
- 被调用函数返回后,调用者先前压入堆栈的参数将被删除,并且函数的返回值的返回值将出现在栈顶;
- 被调用函数返回后,调用者的各个内存段(入 argument,local,static,this,that 和 pointer)跟调用之前一样,temp 未被定义

#### 被调用者角度

- 当被调用的 函数开始执行,其 argument,segment 段被初始化为调用者所传递的参数,为其 local segment 段分配内存空间初始化为 0,它的 static segment 段被置为其所属 vm 文件中的 static segment, 工作堆栈为空,this,that,pointer 和 temp 四个指针均为初始化.
- 返回前,被调用函数必须将某个值压入堆栈.

### 初始化 initialization

VM 程序是一组相关的 VM 函数集合,一般来自于某种高级程序的编译,当 VM 实现开始运行(或者重启),按照惯例,他总是执行名称为 Sys.init 的无参数 VM 函数.接着该函数调用用户程序中的主函数.因此,生成 VM 的编译器必须保证每个翻译后的程序都有这个`Sys.init`函数.

## 实现 Implementation

这一章节介绍了如何完成从第七章开始构建的 VM 实现机制,最终实现整个虚拟机. 其中一些细节还是相当复杂的,深究这些技术细节会使得我们的注意力偏离整个 VM 操作. 因此不必纠结细节.

**全局堆栈** VM 的内存资源是通过维护一个全局的堆栈来得到的,每当调用一个函数时候,该函数对应的帧(frame)就会被压入全局堆栈,该帧包括被调用函数将要用到的参数,一组 用于保存调用者状态的指针(pointer);被调用函数的局部变量(被初始化为 0);以及一个被调用函数将要使用的工作堆栈(当前为空).

[image](./G_STACK.png)
全局堆栈结构

值得注意的是图中的阴影区以及 ARG,LCL 和 SP 指针对于 VM 函数是不可见的(无法感知他们的存在).这三个指针 是更加底层的 VM 实现函数调用与返回协会中使用的.

我们直到如何才能在 Hack 平台上面实现这种模型呢?前面介绍过,标准映射协议制定了堆栈的内存地址应该为 256,意味着 VM 的实现机制可以从生成将 sp 指针设置为 256 的汇编代码(SP=256)开始,于是 每当 VM 实现遇到诸如 pop,push,add 等命令时,就会生成相应的汇编代码,这些代通过操作 sp 和内存中对应的存储单元来实现对应的 pop,push,add 命令.所有这些工作已经在第七章完成,同样的,当 VM 实现遇到诸如 call,function,return 的命令的时候,他也将生成如图 8.4 所示的堆栈结构的汇编代码.

函数调用协议的实现 函数调用协议以及其对应的全局堆栈结构能够执行如图所示.的伪指令.

| 符号                    | 用法                                                                                                                                                                                           |
| ----------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| SP,LCL, ARG, THIS, THAT | 这些预定义符号分别指向栈顶和各虚拟段 local,argument,this,that 的基地址                                                                                                                         |
| R13-R15                 | 这些预定义符号可以用于任何用途                                                                                                                                                                 |
| xxx.h                   | 在 VM 文件中 xxx.vm 中每个静态变量 j 被翻译成汇编符号 xxx.j.在随后的汇编过程中,Hack 汇编编译器会为这些编译器分配 RAM 空间                                                                      |
| functionName\$label     | 在 VM 函数 f 中的每个 label b 命令应该生成唯一的全局符号`f\$b`,这里 f 是函数名,b 是 VM 函数体内的标记符号. 在将 VM 命令 goto b 和 if-goto b 翻译成目标语言时,应该使用完整的符号`f\$b`,而不是 b |
| (FunctionName)          | 每个 VM 函数 f 应该生成一个符号 f,以指代函数 f 在目标计算机指令内存中的地址入口                                                                                                                |
| return-address          | 每个 VM 函数调用应该 生成 并在翻译后的代码中插入唯一的标号,它代表被调用函数(called function)的返回地址,即 内存单元的地址(目标计算机的内存).该 地址就是紧接着调用命令之后的指令地址             |

**引导程序代码** 当 VM-Hack 翻译器编译 VM 程序时,会产生一个用 Hack 汇编语言编写的`.asm`文件.他必须符合规范

1. VM 堆栈的初始地址必须被映射到 RAM[256];
2. 经过编译后的 VM 程序所执行的第一个 VM 函数必须是`Sys.init`

如何在 VM 翻译器生成的`.asm`文件中执行这个初始化呢,在第五章构建 Hack 计算机引荐时候,我们设计得失:在重置 reset 时候获取 ROM[0]的位置并且执行,因此起始于 ROM 的 0 的代码段,称之为`引导程序码`,是计算机 `启动`时候要执行的第一段代码,于是,前面介绍的,计算机的引导程序代码应该执行一下操作

```bash
SP=256          // 将堆栈指针初始化0x0100
call Sys.init   // 开始执行(翻译后的)Sys.init
```

`Sys.init`将调用主程序中的主函数,然后进入无限循环,这样翻译后的 VM 程序就进入运行状态.

程序 `program` ,主程序 `mian program` 和主函数`main function`的概念与编译过程有关,在不同的高级语言中他们的概念并不相同,例如,在 jack 语言中,默认的是自动开始运行的第一个程序单元就是 Main 类中的 main 方法.同样让 JVM 去执行给定的类,JVM 会去寻找并执行 Foo.main 方法,通过正确的编写 Sys.init,每种语言都能执行这样的自动启动程序

### 范例

正数的 n 的阶乘可以用迭代方程`n!=1*2*3...*(n-1)*n`,图 8.7 给出了算法的实现.

现在用重点分析下面图片中的 call mult 命令,

### VM 实现的设计建议

项目 7 中,构建了基本的 VM 翻译模块:Parser 和 CodeWriter. 通过扩展这两个人模块的功能可以实现 2 完整的 VM.\

Parser 模块:项目 7 中构建的语法分析器还不能分析本章介绍的 6 个 VM 命令,这里就把他们追加进来.需要确认的是:项目 7 中开发的 commandType 方法需要返回 6 个 VM 命令对应的常数: `C_LABEL`,`C_TOTO`,`C_IF`,`C_FUNCTION`, `C_RETURN`, `C_CALL`.

CodeWriter 模块:

### SimplerFunction.vm

抽象函数帧在内存中的表现形式

[image](./G_STACK.png)

|        | 调用链中所有函数的调用帧 |                                                                    |
| :----: | :----------------------: | :----------------------------------------------------------------: |
| ARG--> |         argment0         |                                                                    |
|        |         argment1         |                      当前函数的参数被压入堆栈                      |
|        |           ...            |                                                                    |
|        |       argment n-1        |                                                                    |
|        |      return address      |                                                                    |
|        |        saved LCL         |                                                                    |
|        |        saved ARG         | 保存调用函数的状态,以便于在当前被调用函数返回时候,回复调用函数的帧 |
|        |        saved THIS        |                                                                    |
|        |        saved THAT        |                                                                    |
| LCL->  |         local 0          |                                                                    |
|        |         local 1          |                      当前被调用函数的局部变量                      |
|        |           ...            |                                                                    |
|        |        local k-1         |                                                                    |
|  SP->  |                          |                      当前被调用函数的工作堆栈                      |
|        |        🔽🔽🔽🔽🔽        |                                                                    |
